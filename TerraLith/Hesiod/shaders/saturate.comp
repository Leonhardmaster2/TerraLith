#version 450

// Saturate compute shader — matches CPU hmap::saturate exactly.
//
// CPU algorithm (from HighMap/src/filters/recurve.cpp):
//   1. clamp_smooth(array, vmin, vmax, k) — cubic polynomial smooth clamp
//   2. remap(array, from_min, from_max, vmin, vmax) — linear remap
//
// The cubic polynomial smooth clamp (Inigo Quilez) only affects values
// within distance k of the boundary, preserving terrain detail.

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) buffer DataBuf { float data[]; } data_buf;

layout(push_constant) uniform PushConstants
{
  uint  width;
  uint  height;
  float range_min;    // vmin: lower saturation bound
  float range_max;    // vmax: upper saturation bound
  float hmin;         // from_min: output remap lower bound
  float hmax;         // from_max: output remap upper bound
  float k_smoothing;  // k: smoothing radius
} pc;

void main()
{
  uvec2 gid = gl_GlobalInvocationID.xy;
  if (gid.x >= pc.width || gid.y >= pc.height)
    return;

  uint  idx = gid.y * pc.width + gid.x;
  float v = data_buf.data[idx];

  float vmin = pc.range_min;
  float vmax = pc.range_max;
  float k    = pc.k_smoothing;

  // -----------------------------------------------------------------
  // Step 1: Smooth clamp to [vmin, vmax]
  // Matches CPU hmap::clamp_smooth(array, vmin, vmax, k) exactly.
  //
  // clamp_min_smooth: h = max(k - |x - vmin|, 0) / k
  //                   result = max(x, vmin) + h^3 * k / 6
  //
  // clamp_max_smooth: h = max(k - |x - vmax|, 0) / k
  //                   result = min(x, vmax) - h^3 * k / 6
  // -----------------------------------------------------------------
  if (k > 0.0)
  {
    // Smooth lower bound (smooth max with vmin)
    float h = max(k - abs(v - vmin), 0.0) / k;
    v = max(v, vmin) + h * h * h * k / 6.0;

    // Smooth upper bound (smooth min with vmax)
    h = max(k - abs(v - vmax), 0.0) / k;
    v = min(v, vmax) - h * h * h * k / 6.0;
  }
  else
  {
    v = clamp(v, vmin, vmax);
  }

  // -----------------------------------------------------------------
  // Step 2: Remap from [vmin, vmax] to [hmin, hmax]
  // Matches CPU hmap::remap(array, hmin, hmax, vmin, vmax):
  //   result = (x - from_min) / (from_max - from_min) * (vmax - vmin) + vmin
  //   with from_min=vmin, from_max=vmax, vmin=hmin, vmax=hmax:
  //   result = (x - range_min) / (range_max - range_min) * (hmax - hmin) + hmin
  // -----------------------------------------------------------------
  float denom = vmax - vmin;
  if (denom > 0.0)
    v = (v - vmin) / denom * (pc.hmax - pc.hmin) + pc.hmin;
  else
    v = pc.hmin;

  data_buf.data[idx] = v;
}

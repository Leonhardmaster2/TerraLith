#version 450

// Hydraulic erosion compute shader — faithful port of CPU hydraulic_stream.
//
// Two pass types:
//   Pass 0: D-infinity flow accumulation (iterative relaxation)
//           Each cell receives proportional flow from upslope neighbors,
//           matching the CPU's D-inf MFD algorithm (Qin et al. 2007).
//   Pass 1: Apply erosion: z -= c_erosion * remapped_facc * mask
//
// The CPU uses a topological-sort single-pass; this GPU version uses
// iterative Jacobi relaxation over max(w,h) dispatches, with a memory
// barrier between each dispatch ensuring convergence.

layout(local_size_x = 16, local_size_y = 16) in;

// Binding 0: heightmap (read/write between iterations)
layout(set = 0, binding = 0) buffer HeightmapBuf { float height[]; } heightmap;

// Binding 1: flow accumulation scratch buffer
layout(set = 0, binding = 1) buffer FlowAccBuf { float facc[]; } flow_acc;

// Binding 2: erosion map output (optional, accumulates total erosion)
layout(set = 0, binding = 2) buffer ErosionBuf { float erosion[]; } erosion_map;

// Binding 3: mask buffer (1.0 = erode, 0.0 = skip; all 1s if no mask)
layout(set = 0, binding = 3) buffer MaskBuf { float mask[]; } mask_buf;

layout(push_constant) uniform PushConstants
{
  uint  width;
  uint  height;
  float c_erosion;
  float talus_ref;
  float clipping_ratio;
  uint  iteration;      // current relaxation iteration index
  uint  pass_type;      // 0 = flow accumulation relaxation, 1 = erosion apply
} pc;

// Small epsilon to prevent division by zero
const float EPSILON = 1.0e-5;

// 8-connected neighbor layout (matches CPU code):
//   5 1 7
//   0 . 3
//   4 2 6
const int dx[8] = int[8](-1, 0, 0, 1, -1, -1, 1, 1);
const int dy[8] = int[8](0, 1, -1, 0, -1, 1, -1, 1);

// Distance: 1.0 for cardinal, sqrt(2) for diagonal
const float dist[8] = float[8](1.0, 1.0, 1.0, 1.0, 1.414, 1.414, 1.414, 1.414);

// Effective contour length (Quinn et al. 1991):
// 0.5 for cardinal, 0.354 for diagonal
const float ecl[8] = float[8](0.5, 0.5, 0.5, 0.5, 0.354, 0.354, 0.354, 0.354);

// Clamped global read — guarantees in-bounds access
float read_height(int x, int y)
{
  int cx = clamp(x, 0, int(pc.width) - 1);
  int cy = clamp(y, 0, int(pc.height) - 1);
  return heightmap.height[cy * pc.width + cx];
}

float read_facc(int x, int y)
{
  int cx = clamp(x, 0, int(pc.width) - 1);
  int cy = clamp(y, 0, int(pc.height) - 1);
  return flow_acc.facc[cy * pc.width + cx];
}

// D-infinity flow accumulation step (pull-based).
//
// For each cell, compute incoming flow from all upslope neighbors using
// proper D-inf proportional distribution:
//
//   For each upslope neighbor N at direction k:
//     1. Compute gradient_talus at N (max slope to any of N's neighbors)
//     2. Compute flow-partition exponent: p = 10 * clamp(talus/talus_ref, 0, 1) + 1
//     3. Compute D-inf weight from N to us:   w_me = pow(slope_N_to_us, p) * ecl[k]
//     4. Compute D-inf weight from N to ALL:  w_total = sum over downslope of pow(slope, p) * ecl
//     5. Fraction of N's flow going to us:    f = w_me / w_total
//     6. Accumulate:  incoming += f * facc[N]
//
//   facc[cell] = 1.0 + incoming
//
// This matches the CPU's flow_accumulation_dinf() + flow_direction_dinf().
void compute_flow_accumulation_step(int gx, int gy, uint idx)
{
  float z_center = read_height(gx, gy);
  float safe_talus = max(pc.talus_ref, EPSILON);

  float incoming_flow = 0.0;

  for (int k = 0; k < 8; k++)
  {
    int nx = gx + dx[k];
    int ny = gy + dy[k];
    float z_n = read_height(nx, ny);

    // Only consider upslope neighbors (z_n > z_center)
    if (z_n <= z_center)
      continue;

    // --- Compute D-inf fraction of neighbor's flow going to us ---

    // Step 1: Compute gradient_talus at neighbor (max downslope to any neighbor).
    // This determines the flow-partition exponent p (Qin et al. 2007).
    float max_slope_n = 0.0;
    for (int j = 0; j < 8; j++)
    {
      float z_j = read_height(nx + dx[j], ny + dy[j]);
      float slope_j = (z_n - z_j) / dist[j];
      max_slope_n = max(max_slope_n, slope_j);
    }

    // Step 2: Flow-partition exponent — matches CPU:
    //   talus = gradient_talus(z) / talus_ref;  clamp_max(talus, 1);
    //   p = 10 * talus + 1;
    // Higher p concentrates flow into steepest direction (1 = diffuse, 11 = sharp)
    float talus_ratio = clamp(max_slope_n / safe_talus, 0.0, 1.0);
    float p_exp = 10.0 * talus_ratio + 1.0;

    // Step 3: Weight from neighbor to us — the slope from N down to us
    float slope_to_me = (z_n - z_center) / dist[k];
    float weight_to_me = pow(slope_to_me, p_exp) * ecl[k];

    // Step 4: Total D-inf weight from neighbor to ALL its downslope cells
    // This includes the weight to us (when j corresponds to direction back to us)
    float total_weight = 0.0;
    for (int j = 0; j < 8; j++)
    {
      float z_j = read_height(nx + dx[j], ny + dy[j]);
      float dz = z_n - z_j;
      if (dz > 0.0)
      {
        float slope = dz / dist[j];
        total_weight += pow(slope, p_exp) * ecl[j];
      }
    }

    // Step 5-6: Fraction of neighbor's flow to us, accumulated
    if (total_weight > EPSILON)
    {
      float fraction = weight_to_me / total_weight;
      incoming_flow += fraction * read_facc(nx, ny);
    }
  }

  // Total flow accumulation: 1 (self/rainfall) + incoming from upslope
  flow_acc.facc[idx] = 1.0 + incoming_flow;
}

// Apply erosion using the computed flow accumulation.
// By the time this pass runs, flow_acc has been downloaded to CPU,
// clipped, remapped to [0, 1], and re-uploaded — matching the CPU path:
//   vmax = clipping_ratio * sqrt(mean(facc))
//   clamp(facc, 0, vmax)
//   remap(facc) → [0, 1]
void apply_erosion(int gx, int gy, uint idx)
{
  float m = mask_buf.mask[idx];
  if (m <= 0.0)
    return;

  // Flow accumulation has been remapped to [0, 1] by CPU-side remap stage
  float facc_val = flow_acc.facc[idx];
  float z_old = heightmap.height[idx];

  // Compute erosion amount: same as CPU's  z -= c_erosion * facc
  float dz = pc.c_erosion * facc_val * m;

  // Clamp erosion: cannot erode more than the available height above zero,
  // and dz must be non-negative
  dz = clamp(dz, 0.0, max(z_old, 0.0));

  float z_new = z_old - dz;

  // Final NaN/Inf guard: if something still went wrong, preserve old value
  if (isinf(z_new) || isnan(z_new))
    z_new = z_old;

  heightmap.height[idx] = z_new;

  // Accumulate erosion amount (clamped positive)
  erosion_map.erosion[idx] += dz;
}

void main()
{
  uvec2 gid = gl_GlobalInvocationID.xy;
  if (gid.x >= pc.width || gid.y >= pc.height)
    return;

  int  gx  = int(gid.x);
  int  gy  = int(gid.y);
  uint idx = gid.y * pc.width + gid.x;

  if (pc.pass_type == 0)
  {
    // Pass 0: Flow accumulation relaxation step
    compute_flow_accumulation_step(gx, gy, idx);
  }
  else
  {
    // Pass 1: Apply erosion
    apply_erosion(gx, gy, idx);
  }
}

#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) buffer InputBuf  { float data[]; } input_buf;
layout(set = 0, binding = 1) buffer OutputR   { float data[]; } out_r;
layout(set = 0, binding = 2) buffer OutputG   { float data[]; } out_g;
layout(set = 0, binding = 3) buffer OutputB   { float data[]; } out_b;

layout(push_constant) uniform PushConstants
{
  uint width;
  uint height;
} pc;

float get_height(int x, int y)
{
  int cx = clamp(x, 0, int(pc.width) - 1);
  int cy = clamp(y, 0, int(pc.height) - 1);
  return input_buf.data[cy * pc.width + cx];
}

void main()
{
  uvec2 gid = gl_GlobalInvocationID.xy;
  if (gid.x >= pc.width || gid.y >= pc.height)
    return;

  int ix = int(gid.x);
  int iy = int(gid.y);

  // Compute gradients using central differences with edge clamping,
  // scaled by grid dimensions (matching CPU: gradient_x * shape.x)
  float dx = 0.5 * (get_height(ix + 1, iy) - get_height(ix - 1, iy)) * float(pc.width);
  float dy = 0.5 * (get_height(ix, iy + 1) - get_height(ix, iy - 1)) * float(pc.height);

  // Normal vector: n = normalize(-dx, -dy, 1)
  vec3 n = normalize(vec3(-dx, -dy, 1.0));

  // Encode to [0, 1] range for normal map storage
  uint idx = gid.y * pc.width + gid.x;
  out_r.data[idx] = 0.5 * (n.x + 1.0);
  out_g.data[idx] = 0.5 * (n.y + 1.0);
  out_b.data[idx] = 0.5 * (n.z + 1.0);
}
